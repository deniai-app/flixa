export interface DiffValidationResult {
  valid: boolean;
  error?: string;
}

export interface ParsedDiffHunk {
  oldStart: number;
  oldCount: number;
  newStart: number;
  newCount: number;
  lines: string[];
}

export interface ParsedDiff {
  oldFile: string;
  newFile: string;
  hunks: ParsedDiffHunk[];
}

export function validateDiff(
  diff: string,
  flow: 'codelens' | 'chat',
  activeFilePath: string,
  scopeRange?: { startLine: number; endLine: number }
): DiffValidationResult {
  if (!diff || diff.trim() === '') {
    return { valid: false, error: 'Empty diff received' };
  }

  const parsed = parseDiff(diff);
  if (!parsed) {
    return { valid: false, error: 'Failed to parse unified diff' };
  }

  const files = getFilesFromDiff(diff);
  if (files.length !== 1) {
    return {
      valid: false,
      error: `Diff must touch exactly one file. Found: ${files.length} files`,
    };
  }

  if (flow === 'chat') {
    const diffFileName = files[0];
    const activeFileName = activeFilePath.split('/').pop() || activeFilePath;
    if (diffFileName !== activeFileName && !activeFilePath.endsWith(diffFileName)) {
      return {
        valid: false,
        error: `Diff file (${diffFileName}) does not match active file (${activeFilePath})`,
      };
    }
  }

  if (flow === 'codelens' && scopeRange) {
    const changedLines = getChangedLineNumbers(parsed);
    for (const lineNum of changedLines) {
      if (lineNum < scopeRange.startLine || lineNum > scopeRange.endLine) {
        return {
          valid: false,
          error: `Diff changes line ${lineNum} which is outside the scope range (${scopeRange.startLine}-${scopeRange.endLine})`,
        };
      }
    }
  }

  const totalChangedLines = countChangedLines(parsed);
  if (totalChangedLines > 400) {
    return {
      valid: false,
      error: `Total changed lines (${totalChangedLines}) exceeds limit of 400`,
    };
  }

  if (isBinaryPatch(diff)) {
    return { valid: false, error: 'Binary patches are not supported' };
  }

  return { valid: true };
}

export function parseDiff(diff: string): ParsedDiff | null {
  const lines = diff.split('\n');
  let oldFile = '';
  let newFile = '';
  const hunks: ParsedDiffHunk[] = [];
  let currentHunk: ParsedDiffHunk | null = null;

  for (const line of lines) {
    if (line.startsWith('--- ')) {
      oldFile = line.substring(4).replace(/^a\//, '');
    } else if (line.startsWith('+++ ')) {
      newFile = line.substring(4).replace(/^b\//, '');
    } else if (line.startsWith('@@')) {
      if (currentHunk) {
        hunks.push(currentHunk);
      }
      const match = line.match(/@@ -(\d+)(?:,(\d+))? \+(\d+)(?:,(\d+))? @@/);
      if (match) {
        currentHunk = {
          oldStart: parseInt(match[1], 10),
          oldCount: parseInt(match[2] || '1', 10),
          newStart: parseInt(match[3], 10),
          newCount: parseInt(match[4] || '1', 10),
          lines: [],
        };
      }
    } else if (currentHunk) {
      if (
        line.startsWith(' ') ||
        line.startsWith('+') ||
        line.startsWith('-') ||
        line === ''
      ) {
        currentHunk.lines.push(line);
      }
    }
  }

  if (currentHunk) {
    hunks.push(currentHunk);
  }

  if (!oldFile && !newFile) {
    return null;
  }

  return { oldFile, newFile, hunks };
}

/**
 * Parse simplified diff format (no line numbers in @@ markers)
 * This format is sometimes generated by LLMs:
 * @@
 * -old line
 * +new line
 * @@
 * -another old
 * +another new
 */
function parseSimplifiedDiff(diff: string, originalContent: string): ParsedDiff | null {
  const lines = diff.split('\n');
  const hunks: ParsedDiffHunk[] = [];
  let currentHunkLines: string[] = [];
  const originalLines = originalContent.split('\n');

  for (const line of lines) {
    if (line === '@@' || line.startsWith('@@ ')) {
      // Start of a new hunk
      if (currentHunkLines.length > 0) {
        // Process previous hunk
        const hunk = createHunkFromSimplifiedLines(currentHunkLines, originalLines);
        if (hunk) {
          hunks.push(hunk);
        }
        currentHunkLines = [];
      }
    } else if (line.startsWith('+') || line.startsWith('-') || line.startsWith(' ')) {
      currentHunkLines.push(line);
    } else if (line.trim() === '' && currentHunkLines.length > 0) {
      // Empty line within a hunk - could be context
      currentHunkLines.push(' ');
    }
  }

  // Process last hunk
  if (currentHunkLines.length > 0) {
    const hunk = createHunkFromSimplifiedLines(currentHunkLines, originalLines);
    if (hunk) {
      hunks.push(hunk);
    }
  }

  if (hunks.length === 0) {
    return null;
  }

  return { oldFile: '', newFile: '', hunks };
}

function createHunkFromSimplifiedLines(hunkLines: string[], originalLines: string[]): ParsedDiffHunk | null {
  // Extract the lines to search for in original
  const searchLines: string[] = [];
  for (const line of hunkLines) {
    if (line.startsWith('-')) {
      searchLines.push(line.substring(1));
    }
  }

  if (searchLines.length === 0) {
    // No deletions, this is pure additions - need context
    // Look for context lines
    for (const line of hunkLines) {
      if (line.startsWith(' ')) {
        searchLines.push(line.substring(1));
        break;
      }
    }
  }

  if (searchLines.length === 0) {
    console.log('[Flixa] Simplified diff: no search lines found');
    return null;
  }

  // Find where these lines exist in the original
  const firstSearchLine = searchLines[0].trim();
  let foundIndex = -1;

  for (let i = 0; i < originalLines.length; i++) {
    if (originalLines[i].trim() === firstSearchLine) {
      // Verify subsequent lines match too
      let allMatch = true;
      for (let j = 1; j < searchLines.length && i + j < originalLines.length; j++) {
        if (originalLines[i + j].trim() !== searchLines[j].trim()) {
          allMatch = false;
          break;
        }
      }
      if (allMatch || searchLines.length === 1) {
        foundIndex = i;
        break;
      }
    }
  }

  if (foundIndex === -1) {
    console.log(`[Flixa] Simplified diff: could not find "${firstSearchLine}" in original`);
    return null;
  }

  // Count old and new lines
  let oldCount = 0;
  let newCount = 0;
  for (const line of hunkLines) {
    if (line.startsWith('-')) {
      oldCount++;
    } else if (line.startsWith('+')) {
      newCount++;
    } else if (line.startsWith(' ')) {
      oldCount++;
      newCount++;
    }
  }

  console.log(`[Flixa] Simplified diff: found at index ${foundIndex}, oldCount=${oldCount}, newCount=${newCount}`);

  return {
    oldStart: foundIndex + 1, // 1-indexed
    oldCount,
    newStart: foundIndex + 1,
    newCount,
    lines: hunkLines,
  };
}

function getFilesFromDiff(diff: string): string[] {
  const files = new Set<string>();
  const lines = diff.split('\n');

  for (const line of lines) {
    if (line.startsWith('+++ ') && !line.includes('/dev/null')) {
      const file = line.substring(4).replace(/^b\//, '').trim();
      if (file) {
        files.add(file);
      }
    }
  }

  return Array.from(files);
}

function getChangedLineNumbers(parsed: ParsedDiff): number[] {
  const lineNumbers: number[] = [];

  for (const hunk of parsed.hunks) {
    // Convert from 1-based (diff format) to 0-based (VS Code)
    let oldLineNum = hunk.oldStart - 1;

    for (const line of hunk.lines) {
      if (line.startsWith('-')) {
        // Only track deleted/modified lines from the original file
        lineNumbers.push(oldLineNum);
        oldLineNum++;
      } else if (line.startsWith('+')) {
        // Added lines don't exist in original file, skip validation
      } else {
        // Context line
        oldLineNum++;
      }
    }
  }

  return lineNumbers;
}

function countChangedLines(parsed: ParsedDiff): number {
  let count = 0;

  for (const hunk of parsed.hunks) {
    for (const line of hunk.lines) {
      if (line.startsWith('+') || line.startsWith('-')) {
        count++;
      }
    }
  }

  return count;
}

function isBinaryPatch(diff: string): boolean {
  return (
    diff.includes('Binary files') ||
    diff.includes('GIT binary patch') ||
    diff.includes('literal ')
  );
}

export function applyDiffToContent(
  originalContent: string,
  diff: string
): string | null {
  console.log('[Flixa] Raw diff:\n', diff);

  // First try standard unified diff parsing
  let parsed = parseDiff(diff);
  
  // If standard parsing fails, try simplified diff format (no line numbers)
  if (!parsed || parsed.hunks.length === 0) {
    console.log('[Flixa] Standard diff parsing failed, trying simplified format');
    parsed = parseSimplifiedDiff(diff, originalContent);
  }
  
  if (!parsed || parsed.hunks.length === 0) {
    console.log('[Flixa] Failed to parse diff (both formats)');
    return null;
  }

  console.log('[Flixa] Parsed hunks:', JSON.stringify(parsed.hunks, null, 2));

  const lines = originalContent.split('\n');
  console.log('[Flixa] Original line count:', lines.length);

  // Process hunks in reverse order to avoid offset issues
  const sortedHunks = [...parsed.hunks].sort((a, b) => b.oldStart - a.oldStart);

  for (const hunk of sortedHunks) {
    const startIndex = hunk.oldStart - 1;
    console.log(`[Flixa] Processing hunk: oldStart=${hunk.oldStart}, oldCount=${hunk.oldCount}, startIndex=${startIndex}`);

    // Verify context lines match before applying
    let originalLineIndex = startIndex;
    let contextValid = true;

    for (const line of hunk.lines) {
      if (line.startsWith(' ')) {
        // Context line - verify it matches original
        const expectedContent = line.substring(1);
        const actualContent = lines[originalLineIndex];
        if (actualContent !== expectedContent) {
          // Try fuzzy match (trim whitespace)
          if (actualContent?.trim() !== expectedContent.trim()) {
            console.log(`[Flixa] Context mismatch at line ${originalLineIndex + 1}: expected "${expectedContent}", got "${actualContent}"`);
            contextValid = false;
            break;
          }
        }
        originalLineIndex++;
      } else if (line.startsWith('-')) {
        // Deleted line - verify it exists in original
        const expectedContent = line.substring(1);
        const actualContent = lines[originalLineIndex];
        if (actualContent !== expectedContent) {
          // Try fuzzy match (trim whitespace)
          if (actualContent?.trim() !== expectedContent.trim()) {
            console.log(`[Flixa] Delete line mismatch at line ${originalLineIndex + 1}: expected "${expectedContent}", got "${actualContent}"`);
            contextValid = false;
            break;
          }
        }
        originalLineIndex++;
      } else if (line === '') {
        // Empty line in diff can be context or malformed
        // Check if original has empty line at this position
        if (originalLineIndex < lines.length) {
          const actualContent = lines[originalLineIndex];
          if (actualContent === '' || actualContent === undefined) {
            originalLineIndex++;
          }
          // If not empty, don't advance (might be a malformed diff line)
        }
      }
      // '+' lines don't consume original lines
    }

    if (!contextValid) {
      console.log('[Flixa] Context validation failed, attempting fuzzy apply');
      // Try fuzzy matching to find the correct location
      const fuzzyResult = applyHunkFuzzy(lines, hunk);
      if (fuzzyResult === null) {
        console.log('[Flixa] Fuzzy apply also failed');
        return null;
      }
      // fuzzyResult modifies lines in place
      continue;
    }

    // Build the new lines for this hunk
    const newLines: string[] = [];

    for (const line of hunk.lines) {
      if (line.startsWith('+')) {
        // Added line - include in new content
        newLines.push(line.substring(1));
      } else if (line.startsWith('-')) {
        // Removed line - skip (don't include in new content)
      } else if (line.startsWith(' ')) {
        // Context line - use content from original to preserve exact whitespace
        const contextContent = line.substring(1);
        newLines.push(contextContent);
      } else if (line === '') {
        // Empty line in diff - treat as empty context line
        newLines.push('');
      }
    }

    console.log(`[Flixa] Replacing ${hunk.oldCount} lines at index ${startIndex} with ${newLines.length} new lines`);

    // Replace the old lines with new lines
    lines.splice(startIndex, hunk.oldCount, ...newLines);
  }

  console.log('[Flixa] Final line count:', lines.length);
  return lines.join('\n');
}

function applyHunkFuzzy(lines: string[], hunk: ParsedDiffHunk): boolean | null {
  // Extract context and deleted lines to find the match location
  const searchLines: string[] = [];
  for (const line of hunk.lines) {
    if (line.startsWith(' ')) {
      searchLines.push(line.substring(1));
    } else if (line.startsWith('-')) {
      searchLines.push(line.substring(1));
    }
  }

  if (searchLines.length === 0) {
    // No context to match, can't apply fuzzy
    return null;
  }

  // Search for the first context/deleted line in the original
  const firstSearchLine = searchLines[0].trim();
  let bestMatchIndex = -1;
  let bestMatchScore = 0;

  // Search within a reasonable range of the expected position
  const searchStart = Math.max(0, hunk.oldStart - 50);
  const searchEnd = Math.min(lines.length, hunk.oldStart + 50);

  for (let i = searchStart; i < searchEnd; i++) {
    if (lines[i]?.trim() === firstSearchLine) {
      // Check if subsequent lines also match
      let matchScore = 1;
      for (let j = 1; j < searchLines.length && i + j < lines.length; j++) {
        if (lines[i + j]?.trim() === searchLines[j].trim()) {
          matchScore++;
        } else {
          break;
        }
      }
      if (matchScore > bestMatchScore) {
        bestMatchScore = matchScore;
        bestMatchIndex = i;
      }
    }
  }

  if (bestMatchIndex === -1 || bestMatchScore < searchLines.length * 0.5) {
    // Not enough matches found
    return null;
  }

  console.log(`[Flixa] Fuzzy match found at index ${bestMatchIndex} (expected ${hunk.oldStart - 1}), score ${bestMatchScore}/${searchLines.length}`);

  // Build the new lines
  const newLines: string[] = [];
  for (const line of hunk.lines) {
    if (line.startsWith('+')) {
      newLines.push(line.substring(1));
    } else if (line.startsWith('-')) {
      // Skip deleted lines
    } else if (line.startsWith(' ')) {
      newLines.push(line.substring(1));
    } else if (line === '') {
      newLines.push('');
    }
  }

  // Apply at the fuzzy-matched location
  lines.splice(bestMatchIndex, hunk.oldCount, ...newLines);
  return true;
}
